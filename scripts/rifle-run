#!/usr/bin/env sh

# a script that runs debug actions based on the specified filetype
# intented for editors like vim and emacs

. "$(uselib std)"

set -e

if [ $# != 3 ]; then
  printf >&2 "Usage: %s\n" "$(basename $0) <ACTION> <FILETYPE> <FILENAME>"
  printf >&2 "The ACTION and FILETYPE fields are handled based on the code of this script.\n"
  exit 1
fi

if [ -z "$3" ]; then
  printf >&2 "Empty filename.\n"
  exit 1
else
  file=$(realpath -m "$3") || exit 1
fi

tmp=$(mktemp -d) || {
  printf >&2 "Could not generate temp file.\n"
  exit 1
}

printf >&2 "@[TEMP DIR: %s]\n\n" "$tmp"

cleanup() {
  [ -d "$tmp" ] && rm -r "$tmp"
  return 0
}

trap 'cleanup' EXIT

die() {
  printf >&2 "$@"
  cleanup
  exit 1
}

getModelineCommand() {
  # USAGE: feed this with the file contents.
  modeline=$(head -n1)
  if printf "%s" "$modeline" | grep -q '^#!.*'; then
    printf "%s" "$modeline" | sed 's/^#!//g'
  fi
}

readModeline() { head -n1; }

getPython() {
  if [ "$_python_cache" ]; then
    printf "%s" "$_python_cache"
    return
  fi

  if exists python3; then
    printf "%s" "python3"
    _python_cache="python3"
  elif exists python2; then
    printf "%s" "python2"
    _python_cache="python2"
  elif exists python; then
    printf "%s" "python"
    _python_cache="python"
  elif exists py; then
    printf "%s" "py"
    _python_cache="py"
  else
    die "Could not find a suitable python version\n"
  fi
}

fparent_pattern() {
  pattern="$1"
  path="$PWD"

  # okay=0
  while :; do
    cd "$path"

    for file in * .*; do
      if [ "$file" != . ] && [ "$file" != .. ]; then
        if printf "%s" "$file" | grep -q "$pattern"; then
          printf "%s" "$path"
          return 0
        fi
      fi
    done

    [ "$path" = / ] && return 1
    path=$(realpath -m "$path/..")
  done
}

case "$1" in
  run)
    case "$2" in
      @make) fparent-run "Makefile" run-command file-dir make run ;;
      @zig-build) fparent-run "build.zig" run-command file-dir zig build run --color off ;;
      @cargo) fparent-run "Cargo.toml" run-command file-dir cargo run ;;
      @nimble)
        dir=$(fparent_pattern '\.nimble$') || exit 1
        echo "$dir"
        cd "$dir"
        nimble run
        ;;
      @gradlew) fparent-run "gradlew" run-file script-dir run ;;
      rust) rustc "$file" -o "$tmp/exe" && "$tmp/exe" ;;
      gdscript) Godot -s "$file" --no-window ;;
      haskell)
        nameFull=${file%.*}
        name=$(basename "$nameFull")

        (
          cd "$tmp"
          ghc -o "$tmp/exe" -dynamic "$file"
          rm "$nameFull.o" "$nameFull.hi"
        )

        "$tmp/exe"
        ;;
      c) gcc "$file" -o "$tmp/exe" -Wpedantic -Wall && "$tmp/exe" ;;
      d) dmd -run "$file" ;;
      cpp|c++|cc) g++ "$file" -o "$tmp/exe" -std=c++20 -Wpedantic -Wall && "$tmp/exe" ;;
      cs|csharp) mcs "$file" -out:"$tmp/exe" && mono "$tmp/exe" ;;
      clojure) clojure "$file" ;;
      markdown) md-preview "$file" ;;
      php) php "$file" ;;
      sh)
        if [ -x "$file" ]; then
          # execute file if it is executable
          "$file"
        else
          # deduce modeline, if any
          command=$(getModelineCommand < "$file")
          if printf "%s" "$command" | grep -q 'bash$'; then
            bash "$file"
          elif printf "%s" "$command" | grep -q 'zsh$'; then
            zsh "$file"
          elif printf "%s" "$command" | grep -q 'fish$'; then
            fish "$file"
          else
            sh "$file"
          fi
        fi
        ;;
      zsh) if [ -x "$file" ]; then "$file"; else zsh "$file"; fi ;;
      julia) julia "$file" ;;
      vim) nvim -u "$file" ;;
      scheme) guile "$file" ;;
      latex|tex)
        name=$(basename "${file%.*}")
        # pdflatex -output-directory "$tmp" "$file" </dev/null
        latexmk -pdf -outdir="$tmp" "$file" </dev/null
        OPEN_GUI=1 open "$tmp/$name.pdf"
        ;;
      python)
        python=$(getPython)
        "$python" "$file"
        ;;
      hy) hy "$file" ;;
      fsharp) fsharpi "$file" ;;
      lua) lua "$file" ;;
      nim)
        nim compile --out:"out" --outdir:"$tmp" "$file"
        "$tmp/out"
        ;;
      ruby) ruby "$file" ;;
      racket) racket "$file" ;;
      html) openfork "$file" ;;
      svg) openfork "$file" ;;
      moon) moon "$file" ;;
      teal) tl run "$file" ;;
      zig) zig run "$file" --color off --cache-dir "$tmp" ;;
      fennel) fennel "$file" ;;
      crystal) crystal run "$file" ;;
      vlang) v run "$file" ;;
      nelua) nelua "$file" --cache-dir "$tmp" ;;
      javascript)
        if exists deno; then
          deno "$file"
        else
          nodejs "$file"
        fi
        ;;
      java)
        printf >&2 "[ Warning ] the class with the main method needs to be 'Main'\n" # TODO: fix this limitation
        cd "$tmp"
        ln -s "$file" Main.java
        javac -encoding utf8 -d "$tmp" Main.java
        # maybe I could scan the compiled file here to find the entry point? idk
        java Main
        ;;
      janet)
        janet "$file"
        ;;
      haxe)
        printf >&2 "[ Warning ] the class with the main method needs to be 'Main'\n" # TODO: fix this limitation
        cd "$tmp"
        ln -s "$file" Main.hx

        haxe --run Main --main Main
        ;;
      *) die '(action "%s") unhandled filetype: %s\n' "$1" "$2" ;;
    esac ;;
  build)
    case "$2" in
      @make) fparent-run "Makefile" run-command file-dir make ;;
      @cargo) fparent-run "Cargo.toml" run-command file-dir cargo build ;;
      @nimble)
        dir=$(fparent_pattern '\.nimble$') || exit 1
        echo "$dir"
        cd "$dir"
        nimble build
        ;;
      @zig-build) fparent-run "build.zig" run-command file-dir zig build --color off ;;
      zig) zig build-exe "$file" --color off --cache-dir "$tmp" ;;
      @gradlew) fparent-run "gradlew" run-file script-dir build ;;
      markdown) md-compile "$file" > "$HOME/$(basename "$file").$(date +%Y-%m-%d).html" ;;
      fennel) fennel --compile "$file" 2>&1 | nvim +PagerMode ;;
      moon) moonc -p "$file" 2>&1 | nvim +PagerMode ;;
      crystal) crystal build "$file" -o "$tmp/out" ;;
      teal)
        tl gen "$file" --output "$tmp/out"
        nvim +PagerMode "$tmp/out"
        ;;
      java)
        printf >&2 "[ Warning ] the class with the main method needs to be 'Main'\n" # TODO: fix this limitation
        cd "$tmp"
        ln -s "$file" Main.java
        javac -encoding utf8 -d "$tmp" Main.java
        ;;
      *) die '(action "%s") unhandled filetype: %s\n' "$1" "$2" ;;
    esac ;;
  test)
    case "$2" in
      @make) fparent-run "Makefile" run-command file-dir make test ;;
      @cargo) fparent-run "Cargo.toml" run-command file-dir cargo test ;;
      @nimble)
        dir=$(fparent_pattern '\.nimble$') || exit 1
        echo "$dir"
        cd "$dir"
        nimble test
        ;;
      @zig-build) fparent-run "build.zig" run-command file-dir zig build test --color off ;;
      zig) zig test "$file" --color off --cache-dir "$tmp" ;;
      rust) rustc --test "$file" -o "$tmp/exe" && "$tmp/exe" ;;
      *) die '(action "%s") unhandled filetype: %s\n' "$1" "$2" ;;
    esac ;;
  check)
    case "$2" in
      @make) fparent-run "Makefile" run-command file-dir make check ;;
      @zig-build) fparent-run "build.zig" run-command file-dir zig build --color off ;;
      @cargo) fparent-run "Cargo.toml" run-command file-dir cargo check ;;
      @nimble)
        dir=$(fparent_pattern '\.nimble$') || exit 1
        echo "$dir"
        cd "$dir"
        nimble build # `check` doesn't seem to work well
        ;;
      lua) luacheck "$file" ;;
      rust) rustc "$file" -o "$tmp/exe" ;;
      nim) nim compile --out:"out" --outdir:"$tmp" "$file" ;;
      cpp|c++|cc)
        if exists clang-tidy; then
          clang-tidy "$file"
        else
          g++ -c "$file" -o "$tmp/exe" -std=c++20 -Wall -Wpedantic
        fi
        ;;
      teal) tl check "$file" ;;
      python)
        python=$(getPython)
        dmypy run --timeout 600 "$file" &
        proc2="$!"
        "$python" -m pylint "$file" &
        proc1="$!"

        wait "$proc1"
        wait "$proc2"
        ;;
      *) die '(action "%s") unhandled filetype: %s\n' "$1" "$2" ;;
    esac ;;
  *) die "Invalid action: %s\n" "$1" ;;
esac
