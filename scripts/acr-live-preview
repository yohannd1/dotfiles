#!/usr/bin/env python3

import os
import sys
from time import sleep
from pathlib import Path
from dataclasses import dataclass
from typing import Callable, Any, Optional

from subprocess import Popen, PIPE
from queue import Queue, Empty
from threading import Thread

from http.server import SimpleHTTPRequestHandler
from socketserver import TCPServer, ThreadingMixIn

from watchdog.events import FileSystemEvent, FileSystemEventHandler, FileModifiedEvent
from watchdog.observers import Observer

# TODO: refactor this into a more generic utility, or something. I'd like this to be a library, but how do I set up a proper local-to-dotfiles python library anyway?
# TODO: close everything when a KeyboardInterrupt is received
# TODO: option for timeout (so I don't need to feed 3 friggin KeyboardInterrupts for it to close...)

opener = os.environ.get("OPENER") or "xdg-open"


@dataclass
class Args:
    file_to_watch: Path
    output_file: Path
    katex_path: Path


class BroadcasterThread(Thread):
    def __init__(self) -> None:
        super().__init__()
        self._queue: Queue[Any] = Queue()
        self._consumers: set[Queue] = set()

    def add_consumer(self, consumer: Queue) -> None:
        self._queue.put(("add_consumer", consumer))

    def remove_consumer(self, consumer: Queue) -> None:
        self._queue.put(("remove_consumer", consumer))

    def broadcast(self, message) -> None:
        self._queue.put(("broadcast", message))

    def run(self) -> None:
        while True:
            match self._queue.get():
                case ("add_consumer", q):
                    self._consumers.add(q)
                case ("remove_consumer", q):
                    self._consumers.remove(q)
                case ("broadcast", message):
                    for c in self._consumers:
                        c.put(message)
                case unk:
                    print(f"WARNING: got unknown item {unk}")


broadcaster = BroadcasterThread()


class ChangesMonitorThread(Observer):
    callbacks: list[tuple[Any, Callable]]

    def __init__(self, file_to_watch: Path):
        super().__init__()
        self.callbacks = []

        cmt = self

        class Handler(FileSystemEventHandler):
            def on_any_event(self, event: FileSystemEvent) -> None:
                if Path(event.src_path) != file_to_watch:
                    return

                for event_type, callback in cmt.callbacks:
                    if isinstance(event, event_type):
                        callback(event)

        super().schedule(Handler(), file_to_watch.parent, recursive=False)

    def on_event(self, event_type) -> Callable[[Any], None]:
        def inner(func) -> None:
            self.callbacks.append((event_type, func))

        return inner


def compile_file(args: Args) -> None:
    c_args: list[str] = []
    c_args += ["acr2html", str(args.file_to_watch)]
    c_args += ["-o", str(args.output_file)]
    c_args += ["-k", str(args.katex_path)]

    os.environ["OPEN_NEW_WINDOW"] = "1"

    js_to_inject = """
    <script>
    const es = new EventSource("/api/stream");
    es.onmessage = (_) => window.location.reload();
    es.onerror = (e) => {
        debug.error("EventSource error:");
        debug.error(e);
        setTimeout(
            () => alert("An error ocurred! See console for info."),
            1500
        )
    };
    </script>
    """

    def inject_html(file) -> None:
        file.write(js_to_inject)

    with Popen(c_args, stderr=PIPE) as proc:
        exit_code = proc.wait()
        assert proc.stderr is not None
        stderr_output = proc.stderr.read().decode("utf-8")

    print(
        f"--- PROGRAM OUTPUT (stderr) ---\n{stderr_output}\n-------------------------------\n",
        file=sys.stderr,
    )

    if exit_code == 0:
        with args.output_file.open("a") as file:
            inject_html(file)
    else:
        with args.output_file.open("w") as file:
            sanitized_stderr = stderr_output.replace("<", "&lt;").replace(">", "&gt;")
            file.write(
                "<DOCTYPE html>"
                "<html>"
                '<meta charset="utf-8"/>'
                "<style>"
                """
                code, pre {
                    white-space: pre-wrap;
                    overflow-wrap: break-word;
                    word-wrap: break-word;
                    max-width: 100%;
                }
                """
                "</style>"
                "<h3>An error ocurred while parsing the file.</h3>"
                "<p>Program output:</p>"
                f"<pre><code>{sanitized_stderr}</code></pre>"
                "<p>See the live-preview output for (potentially) more details.</p>"
                "</html>"
            )
            inject_html(file)


class CompilerThread(Thread):
    def __init__(self, args: Args):
        super().__init__()
        self._queue: Queue[Any] = Queue()
        self._args = args

    def request_compile(self) -> None:
        self._queue.put("compile")

    def request_open(self, path: str) -> None:
        self._queue.put(("open", path))

    def run(self) -> None:
        while True:
            wants_compile = False
            open_path = None

            # wait for an item, then sleep for a while and get all that piled up
            # this way we can detected duplicated "file modified" events and avoid recompiling multiple times in a short period
            items = [self._queue.get()]
            sleep(0.2)
            while True:
                try:
                    items.append(self._queue.get(block=False))
                except Empty:
                    break

            for item in items:
                match item:
                    case "compile":
                        wants_compile = True
                    case ("open", path):
                        open_path = path
                    case unk:
                        print(f"WARNING: got unknown item {unk}")

            if wants_compile:
                print("** Compiling **")
                compile_file(self._args)
                broadcaster.broadcast("send_reload")

            if open_path is not None:
                _ = Popen([opener, open_path]) # pylint: disable=consider-using-with


compiler: Optional[CompilerThread] = None


def server_thread(args: Args) -> None:
    class Handler(SimpleHTTPRequestHandler):
        def __init__(self, request, client_address, server):
            super().__init__(
                request, client_address, server, directory=args.output_file.parent
            )

        def send_utf8(self, string: str) -> None:
            self.wfile.write(bytes(string, "utf-8"))

        def flush(self) -> None:
            self.wfile.flush()

        def handle_sse_stream(self) -> None:
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.end_headers()

            queue: Queue[Any] = Queue()
            broadcaster.add_consumer(queue)
            try:
                while True:
                    match queue.get():
                        case "send_reload":
                            self.send_utf8("data: reload\n\n")
                            self.flush()
                        case "stop":
                            break
            except BrokenPipeError:
                print("SSE connection aborted")
            finally:
                broadcaster.remove_consumer(queue)

        def do_GET(self) -> None:
            if self.path == "/api/stream":
                self.handle_sse_stream()
                return

            super().do_GET()

    class ThreadedServer(ThreadingMixIn, TCPServer): ...

    with ThreadedServer(("localhost", 0), Handler) as httpd:
        host_r, port, *_ = httpd.server_address

        if isinstance(host_r, bytes):
            host = host_r.decode("utf-8")
        else:
            assert isinstance(host_r, str)
            host = host_r

        url = f"http://{host}:{port}"

        print(f"Server opened at {url}")

        assert compiler is not None
        compiler.request_open(f"{url}/{args.output_file.name}")

        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("KeyboardInterrupt received - server stopped")


def main() -> None:
    args = Args(
        file_to_watch=Path(os.environ["FILE_TO_WATCH"]),
        output_file=Path(os.environ["OUTPUT_FILE"]),
        katex_path=Path(os.environ["KATEX_PATH"]),
    )

    global compiler
    compiler = CompilerThread(args)
    compiler.request_compile()

    changes_monitor = ChangesMonitorThread(args.file_to_watch)

    @changes_monitor.on_event(FileModifiedEvent)
    def on_file_modified(_) -> None:
        assert compiler is not None
        compiler.request_compile()

    threads: list[Thread] = [
        Thread(target=lambda: server_thread(args)),
        broadcaster,
        changes_monitor,
        compiler,
    ]

    for t in threads:
        t.start()

    for t in threads:
        t.join()


if __name__ == "__main__":
    main()
