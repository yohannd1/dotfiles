#!/usr/bin/env python3

from __future__ import annotations

import os
import sys
from abc import abstractmethod
from time import sleep
from pathlib import Path
from dataclasses import dataclass
from typing import Callable, Any, Optional

from subprocess import Popen, PIPE
from queue import Queue, Empty
from threading import Thread

from http.server import SimpleHTTPRequestHandler
from socketserver import TCPServer, ThreadingMixIn

from watchdog.events import FileSystemEvent, FileSystemEventHandler, FileModifiedEvent
from watchdog.observers import Observer

# TODO: refactor this into a more generic utility, or something. I'd like this to be a library, but how do I set up a proper local-to-dotfiles python library anyway?

opener = os.environ.get("OPENER") or "xdg-open"


@dataclass
class Args:
    file_to_watch: Path
    output_file: Path
    katex_path: Path


class StoppableThread(Thread):
    @abstractmethod
    def request_stop(self) -> None: ...


class BroadcasterThread(StoppableThread):
    def __init__(self) -> None:
        super().__init__()
        self._queue: Queue[Any] = Queue()
        self._consumers: set[Queue] = set()

    def add_consumer(self, consumer: Queue) -> None:
        self._queue.put(("add_consumer", consumer))

    def remove_consumer(self, consumer: Queue) -> None:
        self._queue.put(("remove_consumer", consumer))

    def broadcast(self, message) -> None:
        self._queue.put(("broadcast", message))

    def request_stop(self) -> None:
        self._queue.put("stop")

    def run(self) -> None:
        while True:
            match self._queue.get():
                case ("add_consumer", q):
                    self._consumers.add(q)
                case ("remove_consumer", q):
                    self._consumers.remove(q)
                case ("broadcast", message):
                    for c in self._consumers:
                        c.put(message)
                case "stop":
                    break
                case unk:
                    raise ValueError(f"got unknown item {unk}")

broadcaster = BroadcasterThread()


class ChangesMonitorThread(Observer):
    callbacks: list[tuple[Any, Callable]]

    def __init__(self, file_to_watch: Path) -> None:
        super().__init__()
        self.callbacks = []

        class Handler(FileSystemEventHandler):
            def __init__(self, monitor: ChangesMonitorThread):
                super().__init__()
                self.monitor = monitor

            def on_any_event(self, event: FileSystemEvent) -> None:
                assert isinstance(event.src_path, str)

                if Path(event.src_path) != file_to_watch:
                    return

                for event_type, callback in self.monitor.callbacks:
                    if isinstance(event, event_type):
                        callback(event)

        super().schedule(Handler(self), file_to_watch.parent, recursive=False)

    def on_event(self, event_type) -> Callable[[Any], None]:
        def inner(func) -> None:
            self.callbacks.append((event_type, func))

        return inner

    def request_stop(self) -> None:
        self.stop()


RELOAD_JS = """
<script>
const es = new EventSource("/api/stream");
es.onmessage = (_) => window.location.reload();
es.onerror = (e) => {
    debug.error("EventSource error:");
    debug.error(e);
    setTimeout(
        () => alert("An error ocurred! See console for info."),
        1500
    )
};
</script>
"""


def compile_file(args: Args) -> None:
    c_args: list[str] = []
    c_args += ["acr2html", str(args.file_to_watch)]
    c_args += ["-o", str(args.output_file)]
    c_args += ["-k", str(args.katex_path)]

    os.environ["OPEN_NEW_WINDOW"] = "1"

    def inject_html(file) -> None:
        file.write(RELOAD_JS)

    with Popen(c_args, stderr=PIPE) as proc:
        exit_code = proc.wait()
        assert proc.stderr is not None
        stderr_output = proc.stderr.read().decode("utf-8")

    print(
        f"--- PROGRAM OUTPUT (stderr) ---\n{stderr_output}\n-------------------------------\n",
        file=sys.stderr,
    )

    if exit_code == 0:
        with args.output_file.open("a") as file:
            inject_html(file)
    else:
        with args.output_file.open("w") as file:
            sanitized_stderr = stderr_output.replace("<", "&lt;").replace(">", "&gt;")
            file.write(
                "<DOCTYPE html>"
                "<html>"
                '<meta charset="utf-8"/>'
                "<style>"
                """
                code, pre {
                    white-space: pre-wrap;
                    overflow-wrap: break-word;
                    word-wrap: break-word;
                    max-width: 100%;
                }
                """
                "</style>"
                "<h3>An error ocurred while parsing the file.</h3>"
                "<p>Program output:</p>"
                f"<pre><code>{sanitized_stderr}</code></pre>"
                "<p>See the live-preview output for (potentially) more details.</p>"
                "</html>"
            )
            inject_html(file)


class CompilerThread(StoppableThread):
    def __init__(self, args: Args) -> None:
        super().__init__()
        self._queue: Queue[Any] = Queue()
        self._args = args
        self._stop = False

    def request_compile(self) -> None:
        self._queue.put("compile")

    def request_open(self, path: str) -> None:
        self._queue.put(("open", path))

    def _pileup_empty_queue(self) -> list[Any]:
        """Wait for an item, sleep for a while and get everything that piled up after.
        This way we can detect duplicated "file modified" events and avoid recompiling multiple times in a short period.
        """
        PILEUP_TIME = 0.2
        items = [self._queue.get()]
        sleep(PILEUP_TIME)
        while True:
            try:
                items.append(self._queue.get(block=False))
            except Empty:
                break
        return items

    def run(self) -> None:
        while not self._stop:
            wants_compile = False
            open_path = None

            items = self._pileup_empty_queue()

            for item in items:
                match item:
                    case "compile":
                        wants_compile = True
                    case ("open", path):
                        open_path = path
                    case "stop":
                        self._stop = True
                    case unk:
                        raise ValueError(f"got unknown item {unk}")

            if wants_compile:
                print("** Compiling **")
                compile_file(self._args)
                broadcaster.broadcast("send_reload")

            if open_path is not None:
                _ = Popen([opener, open_path])  # pylint: disable=consider-using-with

    def request_stop(self) -> None:
        self._queue.put("stop")


compiler: Optional[CompilerThread] = None


class ServerReqHandler(SimpleHTTPRequestHandler):
    def __init__(self, request, client_address, server, **kwargs):
        super().__init__(
            request, client_address, server, directory=kwargs["args"].output_file.parent
        )

    def send_utf8(self, string: str) -> None:
        self.wfile.write(bytes(string, "utf-8"))

    def flush(self) -> None:
        self.wfile.flush()

    def handle_sse_stream(self) -> None:
        self.send_response(200)
        self.send_header("Content-Type", "text/event-stream")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Connection", "keep-alive")
        self.end_headers()

        queue: Queue[Any] = Queue()
        broadcaster.add_consumer(queue)
        try:
            while True:
                elem = queue.get()
                match elem:
                    case "send_reload":
                        self.send_utf8("data: reload\n\n")
                        self.flush()
                    case "stop":
                        break
        except BrokenPipeError:
            print("warning: SSE connection aborted", file=sys.stderr)
        finally:
            broadcaster.remove_consumer(queue)

    def do_GET(self) -> None:
        if self.path == "/api/stream":
            self.handle_sse_stream()
            return

        super().do_GET()


class ThreadedHTTPServer(ThreadingMixIn, TCPServer):
    def __init__(self, *args):
        super().__init__(*args)
        self.timeout = 0.5


class ServerThread(StoppableThread):
    def __init__(self, args: Args) -> None:
        super().__init__()
        self._args = args
        self._stop = False

    def run(self) -> None:
        def make_handler(*args):
            return ServerReqHandler(*args, args=self._args)

        with ThreadedHTTPServer(("localhost", 0), make_handler) as httpd:
            self._httpd = httpd

            host_r, port, *_ = httpd.server_address

            if isinstance(host_r, bytes):
                host = host_r.decode("utf-8")
            else:
                assert isinstance(host_r, str)
                host = host_r

            url = f"http://{host}:{port}"

            print(f"Server opened at {url}")

            assert compiler is not None
            compiler.request_open(f"{url}/{self._args.output_file.name}")

            while not self._stop:
                httpd.handle_request()

            broadcaster.broadcast("stop")

            print("HTTP", "Stopped...")
            httpd.shutdown()

    def request_stop(self) -> None:
        self._stop = True


def main() -> None:
    args = Args(
        file_to_watch=Path(os.environ["FILE_TO_WATCH"]),
        output_file=Path(os.environ["OUTPUT_FILE"]),
        katex_path=Path(os.environ["KATEX_PATH"]),
    )

    global compiler
    compiler = CompilerThread(args)
    compiler.request_compile()

    changes_monitor = ChangesMonitorThread(args.file_to_watch)

    server = ServerThread(args)

    @changes_monitor.on_event(FileModifiedEvent)
    def on_file_modified(_) -> None:
        assert compiler is not None
        compiler.request_compile()

    threads: list[StoppableThread] = [
        changes_monitor,
        compiler,
    ]

    broadcaster.start()
    server.start()
    for t in threads:
        t.start()

    try:
        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print("Ctrl-C received - stopping...", file=sys.stderr)
        for t in threads:
            t.request_stop()
        for t in threads:
            t.join()

        broadcaster.request_stop()
        broadcaster.join()

        server.request_stop()
        # we were supposed to join here but for some ungodly reason it hangs. so let's just kill this shit.
        os._exit(0)


if __name__ == "__main__":
    main()
