#!/usr/bin/env python3

import os
from time import time, sleep
from pathlib import Path
from dataclasses import dataclass
from typing import Callable

from subprocess import Popen
from queue import Queue
from threading import Thread, Lock

from http.server import SimpleHTTPRequestHandler
from socketserver import TCPServer, ThreadingMixIn

from watchdog.events import FileSystemEvent, FileSystemEventHandler, FileModifiedEvent
from watchdog.observers import Observer

# TODO: refactor this into a more generic utility, or something. I'd like this to be a library, but how do I set up a proper local-to-dotfiles python library anyway?
# TODO: timely API on the client-side that actually waits for changes before reloading

opener = os.environ.get("OPENER") or "xdg-open"
compile_lock = Lock()


@dataclass
class Args:
    file_to_watch: Path
    output_file: Path
    katex_path: Path


class Broadcaster(Thread):
    def __init__(self) -> None:
        super().__init__()
        self._queue = Queue()
        self._consumers: set[Queue] = set()

    def add_consumer(self, consumer: Queue) -> None:
        self._queue.put(("add_consumer", consumer))

    def remove_consumer(self, consumer: Queue) -> None:
        self._queue.put(("remove_consumer", consumer))

    def broadcast(self, message) -> None:
        self._queue.put(("broadcast", message))

    def run(self) -> None:
        while True:
            match self._queue.get():
                case ("add_consumer", q):
                    self._consumers.add(q)
                case ("remove_consumer", q):
                    self._consumers.remove(q)
                case ("broadcast", message):
                    for c in self._consumers:
                        c.put(message)
                case _:
                    pass  # TODO: error? idk


broadcaster = Broadcaster()


def wait_for_changes(
    file_to_watch: Path, event_type, callback: Callable[[FileSystemEvent], None]
) -> None:
    class Handler(FileSystemEventHandler):
        def on_any_event(self, event: FileSystemEvent) -> None:
            if (
                isinstance(event, FileModifiedEvent)
                and Path(event.src_path) == file_to_watch
            ):
                callback(event)

    observer = Observer() # TODO: Observer inherits from Thread! I think I can do this more nicely then.
    observer.schedule(Handler(), file_to_watch.parent, recursive=False)
    observer.start()
    observer.join()


def compile_file(args: Args) -> None:
    c_args: tuple = ("acr2html", args.file_to_watch)
    c_args += ("-o", args.output_file)
    c_args += ("-k", args.katex_path)

    os.environ["OPEN_NEW_WINDOW"] = "1"

    def inject_html(file) -> None:
        file.write(
            """<script>
            const es = new EventSource("/api/stream");
            es.onmessage = (_) => window.location.reload();
            // es.onmessage = (e) => console.log(e.data); // debugging
        </script>"""
        )

    exit_code = Popen(c_args).wait()

    if exit_code == 0:
        with args.output_file.open("a") as file:
            inject_html(file)
    else:
        with args.output_file.open("w") as file:
            file.write(
                "<html><h2>An error ocurred! See live-preview output for details.</h2></html>"
            )
            inject_html(file)


def observer_thread(args: Args) -> None:
    def callback(_) -> None:
        print(f"File modified - {args.file_to_watch}")

        # TODO: a more stable monitoring system... or something. This one ends up recompiling the same file multiple times on one change. That's awful. I think I can do something with queues (in another thread. A compile thread.)

        if not compile_lock.acquire():
            return

        print(f"Recompiling.")

        try:
            compile_file(args)
            broadcaster.broadcast("send_reload")
        finally:
            compile_lock.release()

    wait_for_changes(args.file_to_watch, FileSystemEvent, callback)


def server_thread(args: Args) -> None:
    class Handler(SimpleHTTPRequestHandler):
        def __init__(self, request, client_address, server):
            super().__init__(
                request, client_address, server, directory=args.output_file.parent
            )

        def send_utf8(self, string: str) -> None:
            self.wfile.write(bytes(string, "utf-8"))

        def flush(self) -> None:
            self.wfile.flush()

        def _api_stream(self) -> None:
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.end_headers()

            queue = Queue()
            broadcaster.add_consumer(queue)
            try:
                while True:
                    match queue.get():
                        case "send_reload":
                            self.send_utf8(f"data: reload\n\n")
                            self.flush()
                        case "stop":
                            break
            finally:
                broadcaster.remove_consumer(queue)

        def do_GET(self) -> None:
            if self.path == "/api/stream":
                self._api_stream()
                return

            super().do_GET()

    class ThreadedServer(ThreadingMixIn, TCPServer): ...

    with ThreadedServer(("localhost", 0), Handler) as httpd:
        host, port = httpd.server_address
        url = f"http://{host}:{port}"

        print(f"Server opened at {url}")
        _ = Popen([opener, f"{url}/{args.output_file.name}"])

        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            print("KeyboardInterrupt received - server stopped")


def main() -> None:
    args = Args(
        file_to_watch=Path(os.environ["FILE_TO_WATCH"]),
        output_file=Path(os.environ["OUTPUT_FILE"]),
        katex_path=Path(os.environ["KATEX_PATH"]),
    )

    compile_file(args)

    thread_funcs = [observer_thread, server_thread]
    threads = [Thread(target=f, args=(args,)) for f in thread_funcs] + [broadcaster]

    for t in threads:
        t.start()

    for t in threads:
        t.join()


if __name__ == "__main__":
    main()
