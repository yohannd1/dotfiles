#!/usr/bin/env janet

(use dotf-path)
(use dotf-utils)

(def HOME (assert (os/getenv "HOME") "HOME env var unset"))
(def SHELL (os/getenv "SHELL" "/bin/sh"))
(def EDITOR (os/getenv "EDITOR" "vi"))

(def XDG-CACHE-HOME
  (or (os/getenv "XDG_CACHE_HOME")
      (string HOME "/.cache")))
(def FZRUN-RECENT-CMDS
  (or (os/getenv "FZRUN_RECENT_CMDS")
      (string XDG-CACHE-HOME "/fzrun-recent-cmds")))

(defn file/append-line [path line]
  (with [f (file/open path :an)]
    (:write f line)
    (:write f "\n") # TODO: is this needed?
    ))

(defn run-shell [cmd add-to-recent]
  (when add-to-recent
    (file/append-line FZRUN-RECENT-CMDS cmd))

  # NOTE: previously I used tmux-bg-run here. But not feeling like it rn.
  (exec-exit [SHELL "-c" cmd]))

(defn cmd-menu [add-to-recent]
  (if-let [out (readline-agnostic :prompt "Type the desired command: ")]
    (run-shell (string out) add-to-recent)
    (os/exit 1)))

(defn bin-menu [add-to-recent]
  (def bins
    (as?->
      (run< ["gen-pathbin"]) .x
      (if (nil? .x)
        (die 1 "failed to get binaries list")
        .x)
      (string/trim .x)
      (string/split "\n" .x)))

  (if-let [[n _] (try-brief (fzagnostic bins :prompt "Binary:"))]
    (run-shell (in bins n) add-to-recent)
    (os/exit 1)))

(defn edit-recent []
  (exec-exit [EDITOR FZRUN-RECENT-CMDS]))

(defn main [arg0 & args]
  (unless (empty? args)
    (die 2 "no args should be supplied"))

  (defn is-skippable-line [l]
    (or (empty? l) (string/has-prefix? "#" l)))

  (def base-actions
    [["Run a custom command (add-recent:yes)" |(cmd-menu true)]
     ["Run a custom command (add-recent:no)" |(cmd-menu false)]
     ["Run a binary from the binary list (add-recent:yes)" |(bin-menu true)]
     ["Run a binary from the binary list (add-recent:no)" |(bin-menu false)]
     ["Edit the recent commands file" |(edit-recent)]])

  (def recent-cmds
    (if-let [f (file/open FZRUN-RECENT-CMDS :r)]
      (defer (:close f)
        (->>
          (:read f :all)
          (string/split "\n")
          (map string/trim)
          (filter |(not (is-skippable-line $)))
          (map |[(string "(recnt) " $)
                 (fn [] (run-shell $ false))])
          ))
      []))

  (def actions [;base-actions ;recent-cmds])

  (if-let [[n _] (try-brief (fzagnostic (map first actions) :prompt "Run: "))]
    (if-let [act (get actions n)]
      (-> act (in 1) (apply))
      (die "out of range choice: %j" n))
    (os/exit 1)))
