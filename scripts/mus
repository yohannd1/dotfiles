#!/usr/bin/env janet

(use dotf-path)
(use dotf-utils)

(def TMPDIR (os/getenv "TMPDIR" "/tmp"))
(def HOME (-> (os/getenv "HOME") (assert "no HOME set..?")))
(def state-path (string/format "%s/mus.state" TMPDIR))
(var *progname* nil)

(defn show-help []
  (eprintf "%s: a music playing utility" *progname*)
  (eprintf "Usage:")
  (eprintf "  %s add [FILES...]" *progname*)
  (eprintf "  %s clear" *progname*)
  (eprintf "  %s current" *progname*)
  (eprintf "  %s edit" *progname*)
  (eprintf "  %s queue" *progname*)
  (eprintf "  %s shuffle" *progname*)
  (eprintf "    Shuffle the songs after the current one in the queue.")
  (eprintf "  %s { next | prev } [AMOUNT]" *progname*)
  (eprintf "    Go forward or backwards in the queue by AMOUNT (defaults to 1).")
  (os/exit 2))

(defn shuffle
  "Shuffle an array."
  [arr &opt start end]

  (def i-start (or start 0))
  (def i-end (or end (length arr)))
  (loop [i :range [i-start i-end]]
    (def j (-> (math/random) (* (- i-end i-start 1)) (math/round) (+ i-start)))
    (def tmp (in arr i))
    (set (arr i) (in arr j))
    (set (arr j) tmp)))

(def get-ext-kind
  (do
    (def music-exts
      (make-set ["mp3" "wav" "midi" "ogg" "mus" "m4a" "opus" "flac" "ogx"]))
    (def image-exts
      (make-set ["png" "jpg" "jpeg"]))

    (fn get-ext-kind [ext]
      (cond
        (in music-exts ext) :music
        (in image-exts ext) :image
        :unknown))
    ))

(defmacro with-file [head & body]
  (with-syms [mode-sym]
    (def [file-sym path mode] head)
    ~(let [,mode-sym (keyword ,mode :n)
           ,file-sym (file/open ,path ,mode-sym)]
       (defer (:close ,file-sym)
         ,;body))))

(defn file-get-lines [path]
  (with-file [file path :r]
    (seq [line :in (file/lines file)]
      line)))

(defn load-state []
  (defn default-result []
    @{:index 0 :queue @[]})

  (if (path/exists? state-path)
    (let [contents (file-get-lines state-path)]
      (if (empty? contents)
        (default-result)
        (let
          [index (-> (in contents 0) (string/trim) (scan-number))
           queue (as-> contents .x (array/slice .x 1) (map string/trim .x))]
          @{:index index :queue queue})))
    (default-result)))

(defn save-state [state]
  (with-file [file state-path :w]
    (:write file (string/format "%d\n" (in state :index)))
    (each p (in state :queue)
      (:write file (string p "\n")))))

(defmacro with-state
  "Runs `body` with the state assigned to `cap`. By the end of the scope, if the state object has a truthy :write field, the state is saved."
  [cap & body]

  ~(with-lock state-path
     (let [,cap (load-state)]
       (defer
         (when (in ,cap :write)
           (save-state ,cap))
         ,;body))))

(defn main [arg0 & args]
  (set *progname* (path/basename arg0))
  (def args-len (length args))

  (when (empty? args) (show-help))

  (match (in args 0)
    "add"
    (with-state state
      (def skip-dirs
        (-> (os/getenv "SKIP_DIRS") (or "") (string/trim) (not= "")))

      (defn add-song [fname]
        (assert
          (path/exists? fname)
          (string/format "file %s does not exist" fname))

        (if (path/is-dir? fname)
          (if skip-dirs
            (eprintf "warning: skipping directory %s" fname)
            (each sub (os/dir fname)
              (add-song (string fname "/" sub))))
          (do
            (def real (os/realpath fname))
            (def ext (path/extension real))

            (case (get-ext-kind ext)
              :music (array/push (in state :queue) real)
              :image nil # do nothing
              :unknown (eprintf "warning: skipping %s (unsupported extension %j)" fname ext)))))

      (each arg (array/slice args 1)
        (if (= arg "-")
          (while (def fname (:read stdin :line))
            (add-song (string/trim fname)))
          (add-song arg)))

      (set (state :write) true))

    "clear"
    (with-state state
      (set (state :index) 0)
      (-> (state :queue) (array/clear))
      (set (state :write) true))

    "current"
    (with-state state
      (when (> args-len 1) (show-help))
      (def {:index index :queue queue} state)
      (if (< index (length queue))
        (printf "%d %s" (inc index) (in queue index))
        (do
          (eprintf "queue is \"empty\"")
          (os/exit 1))))

    "edit"
    (let [EDITOR (or (os/getenv "EDITOR") "vi")]
      (with-lock state-path
        (os/execute [EDITOR state-path] :p)))

    "queue"
    (with-state state
      (when (> args-len 1) (show-help))
      (loop [:let [index (in state :index)
                   queue (in state :queue)]
             [i path] :pairs queue]
        (def final-path (path/basename path))
        (def prefix
          (cond
            (< i index) "  "
            (= i index) "* "
            (> i index) "- "))
        (printf "%s%s" prefix final-path)))

    "shuffle"
    (with-state state
      (when (> args-len 1) (show-help))
      (def {:index index :queue queue} state)

      (if (< (+ index 1) (length queue))
        (shuffle queue (+ index 1))
        (eprintf "no elements to shuffle."))

      (set (state :write) true))

    "next"
    (with-state state
      (when (> args-len 2) (show-help))

      (def amount
        (-> args (get 1) (or "1") (scan-number) (math/floor)))
      (set (state :index) (-> state (in :index) (+ amount)))
      (set (state :write) true))

    "prev"
    (with-state state
      (when (> args-len 2) (show-help))

      (def amount (-> args (get 1) (or "1") (scan-number) (math/floor)))
      (set (state :index) (-> state (in :index) (- amount) (max 0)))
      (set (state :write) true))

    "play"
    (do
      (when (> args-len 1) (show-help))

      (defn get-queue-state []
        (with-state {:queue q :index i}
          {:index i
           :queue q
           :cur-song (get q i)}))

      (prompt 'loop
        (while true
          (def
            {:index index
             :queue queue
             :cur-song cur-song}
            (get-queue-state))

          (when (nil? cur-song)
            (eprintf "no more songs to play.")
            (return 'loop))

          (eprintf "(%d of %d) playing %s" (inc index) (length queue) (path/basename cur-song))
          (eprintf "full path: %s" cur-song)

          (os/execute ["mpv" "--no-video" cur-song] :p)
          (eprintf "\n")

          (with-state state
            (def
              {:index index
               :queue queue}
              state)
            (def cur-song-2 (get queue index))
            (if (= cur-song cur-song-2)
              (do
                (set (state :index) (inc index))
                (set (state :write) true))
              (eprintf "warning: current song isn't what I thought it was. I'm lost."))))))

    _ (show-help)
    )
  )
